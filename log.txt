    1  #!/bin/bash
    2  # This script displays various information to the screen.
    3  # Display 'Hello'
    4  echo 'Hello'
    5  # Assign a value to a variable.
    6  WORD='script'
    7  # Display that value using the variable.
    8  echo "$WORD"
    9  # Demonstrate that single quotes cause variables to not get expanded.
   10  echo '$WORD'
   11  # Combine the variable with hard-coded text.
   12  echo "This is a shell $WORD"
   13  # Display the contents of the variable using an alternative syntax.
   14  echo "This is a shell ${WORD}"
   15  # Append text to the variable.
   16  echo "${WORD}ing is fun!"
   17  # Show how NOT to append text to a variable.
   18  # This doesn't work:
   19  echo "$WORDing is fun!"
   20  # Create a new variable
   21  ENDING='ed'
   22  # Combine the two variables.
   23  echo "This is ${WORD}${ENDING}."
   24  # Change the value stored in the ENDING variable.  (Reassignment.)
   25  ENDING='ing'
   26  echo "${WORD}${ENDING} is fun!"
   27  # Reassign value to ENDING.
   28  ENDING='s'
   29  echo "You are going to write many ${WORD}${ENDING} in this class!"
   30  #!/bin/bash
   31  # This script displays various information to the screen.
   32  # Display 'Hello'
   33  echo 'Hello'
   34  # Assign a value to a variable.
   35  WORD='script'
   36  # Display that value using the variable.
   37  echo "$WORD"
   38  # Demonstrate that single quotes cause variables to not get expanded.
   39  echo '$WORD'
   40  # Combine the variable with hard-coded text.
   41  echo "This is a shell $WORD"
   42  # Display the contents of the variable using an alternative syntax.
   43  echo "This is a shell ${WORD}"
   44  # Append text to the variable.
   45  echo "${WORD}ing is fun!"
   46  # Show how NOT to append text to a variable.
   47  # This doesn't work:
   48  echo "$WORDing is fun!"
   49  # Create a new variable
   50  ENDING='ed'
   51  # Combine the two variables.
   52  echo "This is ${WORD}${ENDING}."
   53  # Change the value stored in the ENDING variable.  (Reassignment.)
   54  ENDING='ing'
   55  echo "${WORD}${ENDING} is fun!"
   56  # Reassign value to ENDING.
   57  ENDING='s'
   58  echo "You are going to write many ${WORD}${ENDING} in this class!"
   59  #!/bin/bash
   60  # This script pings a list of servers and reports their status.
   61  SERVER_LIST='/vagrant/servers'
   62  if [[ ! -e "${SERVER_LIST}" ]]; then   echo "Cannot open ${SERVER_LIST}." >&2;   exit 1; fi
   63  #!/bin/bash
   64  javac -classpath /usr/lib/hadoop/hadoop-common.jar:/usr/lib/hadoop/client/hadoop-mapreduce-client-core.jar  exercise.java
   65  jar cvf exercise.jar exercise*.class
   66  #!/bin/sh
   67  ##########################################################################
   68  #
   69  # random apply color-theme from ./color-theme-*/*.sh
   70  #
   71  COLOR_THEME=`ls ./color-theme-*/*.sh|sort -R | head -n1`
   72  echo $COLOR_THEME
   73  source ${COLOR_THEME}
   74  #!/bin/sh
   75  ##########################################################################
   76  #
   77  # random apply color-theme from ./color-theme-*/*.sh
   78  #
   79  COLOR_THEME=`ls ./color-theme-*/*.sh|sort -R | head -n1`
   80  echo $COLOR_THEME
   81  source ${COLOR_THEME}
   82  # bash/zsh git prompt support
   83  #
   84  # Copyright (C) 2006,2007 Shawn O. Pearce <spearce@spearce.org>
   85  # Distributed under the GNU General Public License, version 2.0.
   86  #
   87  # This script allows you to see repository status in your prompt.
   88  #
   89  # To enable:
   90  #
   91  #    1) Copy this file to somewhere (e.g. ~/.git-prompt.sh).
   92  #    2) Add the following line to your .bashrc/.zshrc:
   93  #        source ~/.git-prompt.sh
   94  #    3a) Change your PS1 to call __git_ps1 as
   95  #        command-substitution:
   96  #        Bash: PS1='[\u@\h \W$(__git_ps1 " (%s)")]\$ '
   97  #        ZSH:  setopt PROMPT_SUBST ; PS1='[%n@%m %c$(__git_ps1 " (%s)")]\$ '
   98  #        the optional argument will be used as format string.
   99  #    3b) Alternatively, for a slightly faster prompt, __git_ps1 can
  100  #        be used for PROMPT_COMMAND in Bash or for precmd() in Zsh
  101  #        with two parameters, <pre> and <post>, which are strings
  102  #        you would put in $PS1 before and after the status string
  103  #        generated by the git-prompt machinery.  e.g.
  104  #        Bash: PROMPT_COMMAND='__git_ps1 "\u@\h:\w" "\\\$ "'
  105  #          will show username, at-sign, host, colon, cwd, then
  106  #          various status string, followed by dollar and SP, as
  107  #          your prompt.
  108  #        ZSH:  precmd () { __git_ps1 "%n" ":%~$ " "|%s" }
  109  #          will show username, pipe, then various status string,
  110  #          followed by colon, cwd, dollar and SP, as your prompt.
  111  #        Optionally, you can supply a third argument with a printf
  112  #        format string to finetune the output of the branch status
  113  #
  114  # The repository status will be displayed only if you are currently in a
  115  # git repository. The %s token is the placeholder for the shown status.
  116  #
  117  # The prompt status always includes the current branch name.
  118  #
  119  # In addition, if you set GIT_PS1_SHOWDIRTYSTATE to a nonempty value,
  120  # unstaged (*) and staged (+) changes will be shown next to the branch
  121  # name.  You can configure this per-repository with the
  122  # bash.showDirtyState variable, which defaults to true once
  123  # GIT_PS1_SHOWDIRTYSTATE is enabled.
  124  #
  125  # You can also see if currently something is stashed, by setting
  126  # GIT_PS1_SHOWSTASHSTATE to a nonempty value. If something is stashed,
  127  # then a '$' will be shown next to the branch name.
  128  #
  129  # If you would like to see if there're untracked files, then you can set
  130  # GIT_PS1_SHOWUNTRACKEDFILES to a nonempty value. If there're untracked
  131  # files, then a '%' will be shown next to the branch name.  You can
  132  # configure this per-repository with the bash.showUntrackedFiles
  133  # variable, which defaults to true once GIT_PS1_SHOWUNTRACKEDFILES is
  134  # enabled.
  135  #
  136  # If you would like to see the difference between HEAD and its upstream,
  137  # set GIT_PS1_SHOWUPSTREAM="auto".  A "<" indicates you are behind, ">"
  138  # indicates you are ahead, "<>" indicates you have diverged and "="
  139  # indicates that there is no difference. You can further control
  140  # behaviour by setting GIT_PS1_SHOWUPSTREAM to a space-separated list
  141  # of values:
  142  #
  143  #     verbose       show number of commits ahead/behind (+/-) upstream
  144  #     name          if verbose, then also show the upstream abbrev name
  145  #     legacy        don't use the '--count' option available in recent
  146  #                   versions of git-rev-list
  147  #     git           always compare HEAD to @{upstream}
  148  #     svn           always compare HEAD to your SVN upstream
  149  #
  150  # You can change the separator between the branch name and the above
  151  # state symbols by setting GIT_PS1_STATESEPARATOR. The default separator
  152  # is SP.
  153  #
  154  # By default, __git_ps1 will compare HEAD to your SVN upstream if it can
  155  # find one, or @{upstream} otherwise.  Once you have set
  156  # GIT_PS1_SHOWUPSTREAM, you can override it on a per-repository basis by
  157  # setting the bash.showUpstream config variable.
  158  #
  159  # If you would like to see more information about the identity of
  160  # commits checked out as a detached HEAD, set GIT_PS1_DESCRIBE_STYLE
  161  # to one of these values:
  162  #
  163  #     contains      relative to newer annotated tag (v1.6.3.2~35)
  164  #     branch        relative to newer tag or branch (master~4)
  165  #     describe      relative to older annotated tag (v1.6.3.1-13-gdd42c2f)
  166  #     default       exactly matching tag
  167  #
  168  # If you would like a colored hint about the current dirty state, set
  169  # GIT_PS1_SHOWCOLORHINTS to a nonempty value. The colors are based on
  170  # the colored output of "git status -sb" and are available only when
  171  # using __git_ps1 for PROMPT_COMMAND or precmd.
  172  #
  173  # If you would like __git_ps1 to do nothing in the case when the current
  174  # directory is set up to be ignored by git, then set
  175  # GIT_PS1_HIDE_IF_PWD_IGNORED to a nonempty value. Override this on the
  176  # repository level by setting bash.hideIfPwdIgnored to "false".
  177  # check whether printf supports -v
  178  __git_printf_supports_v=
  179  printf -v __git_printf_supports_v -- '%s' yes >/dev/null 2>&1
  180  # stores the divergence from upstream in $p
  181  # used by GIT_PS1_SHOWUPSTREAM
  182  __git_ps1_show_upstream () { 	local key value; 	local svn_remote svn_url_pattern count n; 	local upstream=git legacy="" verbose="" name="";  	svn_remote=() 	local output="$(git config -z --get-regexp '^(svn-remote\..*\.url|bash\.showupstream)$' 2>/dev/null | tr '\0\n' '\n ')"; 	while read -r key value; do 		case "$key" in 		bash.showupstream) 			GIT_PS1_SHOWUPSTREAM="$value"; 			if [[ -z "${GIT_PS1_SHOWUPSTREAM}" ]]; then 				p=""; 				return; 			fi; 			;; 		svn-remote.*.url) 			svn_remote[$((${#svn_remote[@]} + 1))]="$value"; 			svn_url_pattern="$svn_url_pattern\\|$value"; 			upstream=svn+git # default upstream is SVN if available, else git; 			;; 		esac
  183  	done <<< "$output";  	for option in ${GIT_PS1_SHOWUPSTREAM}; do 		case "$option" in 		git|svn) upstream="$option" ;; 		verbose) verbose=1 ;; 		legacy)  legacy=1  ;; 		name)    name=1 ;; 		esac; 	done;  	case "$upstream" in 	git)    upstream="@{upstream}" ;; 	svn*) 		local -a svn_upstream; 		svn_upstream=($(git log --first-parent -1 \
  184  					--grep="^git-svn-id: \(${svn_url_pattern#??}\)" 2>/dev/null)); 		if [[ 0 -ne ${#svn_upstream[@]} ]]; then 			svn_upstream=${svn_upstream[${#svn_upstream[@]} - 2]}; 			svn_upstream=${svn_upstream%@*}; 			local n_stop="${#svn_remote[@]}"; 			for ((n=1; n <= n_stop; n++)); do 				svn_upstream=${svn_upstream#${svn_remote[$n]}}; 			done;  			if [[ -z "$svn_upstream" ]]; then 				upstream=${GIT_SVN_ID:-git-svn}; 			else 				upstream=${svn_upstream#/}; 			fi; 		elif [[ "svn+git" = "$upstream" ]]; then 			upstream="@{upstream}"; 		fi; 		;; 	esac;  	if [[ -z "$legacy" ]]; then 		count="$(git rev-list --count --left-right \
  185  				"$upstream"...HEAD 2>/dev/null)"; 	else 		local commits; 		if commits="$(git rev-list --left-right "$upstream"...HEAD 2>/dev/null)"; 		then 			local commit behind=0 ahead=0; 			for commit in $commits; 			do 				case "$commit" in 				"<"*) ((behind++)) ;; 				*)    ((ahead++))  ;; 				esac; 			done; 			count="$behind	$ahead"; 		else 			count=""; 		fi; 	fi;  	if [[ -z "$verbose" ]]; then 		case "$count" in 		"") # no upstream 			p="" ;; 		"0	0") # equal to upstream 			p="=" ;; 		"0	"*) # ahead of upstream 			p=">" ;; 		*"	0") # behind upstream 			p="<" ;; 		*)	    # diverged from upstream 			p="<>" ;; 		esac; 	else 		case "$count" in 		"") # no upstream 			p="" ;; 		"0	0") # equal to upstream 			p=" u=" ;; 		"0	"*) # ahead of upstream 			p=" u+${count#0	}" ;; 		*"	0") # behind upstream 			p=" u-${count%	0}" ;; 		*)	    # diverged from upstream 			p=" u+${count#*	}-${count%	*}" ;; 		esac; 		if [[ -n "$count" && -n "$name" ]]; then 			__git_ps1_upstream_name=$(git rev-parse \
  186  				--abbrev-ref "$upstream" 2>/dev/null); 			if [ $pcmode = yes ] && [ $ps1_expanded = yes ]; then 				p="$p \${__git_ps1_upstream_name}"; 			else 				p="$p ${__git_ps1_upstream_name}" 				unset __git_ps1_upstream_name; 			fi; 		fi; 	fi;  }
  187  # Helper function that is meant to be called from __git_ps1.  It
  188  # injects color codes into the appropriate gitstring variables used
  189  # to build a gitstring.
  190  __git_ps1_colorize_gitstring () { 	if [[ -n ${ZSH_VERSION-} ]]; then 		local c_red='%F{red}'; 		local c_green='%F{green}'; 		local c_lblue='%F{blue}'; 		local c_clear='%f'; 	else 		local c_red='\[\e[31m\]'; 		local c_green='\[\e[32m\]'; 		local c_lblue='\[\e[1;34m\]'; 		local c_clear='\[\e[0m\]'; 	fi; 	local bad_color=$c_red; 	local ok_color=$c_green; 	local flags_color="$c_lblue";  	local branch_color=""; 	if [ $detached = no ]; then 		branch_color="$ok_color"; 	else 		branch_color="$bad_color"; 	fi; 	c="$branch_color$c";  	z="$c_clear$z"; 	if [ "$w" = "*" ]; then 		w="$bad_color$w"; 	fi; 	if [ -n "$i" ]; then 		i="$ok_color$i"; 	fi; 	if [ -n "$s" ]; then 		s="$flags_color$s"; 	fi; 	if [ -n "$u" ]; then 		u="$bad_color$u"; 	fi; 	r="$c_clear$r"; }
  191  __git_eread () { 	local f="$1"; 	shift; 	test -r "$f" && read "$@" <"$f"; }
  192  # __git_ps1 accepts 0 or 1 arguments (i.e., format string)
  193  # when called from PS1 using command substitution
  194  # in this mode it prints text to add to bash PS1 prompt (includes branch name)
  195  #
  196  # __git_ps1 requires 2 or 3 arguments when called from PROMPT_COMMAND (pc)
  197  # in that case it _sets_ PS1. The arguments are parts of a PS1 string.
  198  # when two arguments are given, the first is prepended and the second appended
  199  # to the state string when assigned to PS1.
  200  # The optional third parameter will be used as printf format string to further
  201  # customize the output of the git-status string.
  202  # In this mode you can request colored hints using GIT_PS1_SHOWCOLORHINTS=true
  203  __git_ps1 () { 	local exit=$?; 	local pcmode=no; 	local detached=no; 	local ps1pc_start='\u@\h:\w '; 	local ps1pc_end='\$ '; 	local printf_format=' (%s)';  	case "$#" in 		2|3)	pcmode=yes; 			ps1pc_start="$1"; 			ps1pc_end="$2"; 			printf_format="${3:-$printf_format}" 			PS1="$ps1pc_start$ps1pc_end"; 		;; 		0|1)	printf_format="${1:-$printf_format}"; 		;; 		*)	return $exit; 		;; 	esac;  	local ps1_expanded=yes; 	[ -z "$ZSH_VERSION" ] || [[ -o PROMPT_SUBST ]] || ps1_expanded=no; 	[ -z "$BASH_VERSION" ] || shopt -q promptvars || ps1_expanded=no;  	local repo_info rev_parse_exit_code; 	repo_info="$(git rev-parse --git-dir --is-inside-git-dir \
  204  		--is-bare-repository --is-inside-work-tree \
  205  		--short HEAD 2>/dev/null)"; 	rev_parse_exit_code="$?";  	if [ -z "$repo_info" ]; then 		return $exit; 	fi;  	local short_sha; 	if [ "$rev_parse_exit_code" = "0" ]; then 		short_sha="${repo_info##*$'\n'}"; 		repo_info="${repo_info%$'\n'*}"; 	fi; 	local inside_worktree="${repo_info##*$'\n'}"; 	repo_info="${repo_info%$'\n'*}"; 	local bare_repo="${repo_info##*$'\n'}"; 	repo_info="${repo_info%$'\n'*}"; 	local inside_gitdir="${repo_info##*$'\n'}"; 	local g="${repo_info%$'\n'*}";  	if [ "true" = "$inside_worktree" ] && 	   [ -n "${GIT_PS1_HIDE_IF_PWD_IGNORED-}" ] && 	   [ "$(git config --bool bash.hideIfPwdIgnored)" != "false" ] && 	   git check-ignore -q .; 	then 		return $exit; 	fi;  	local r=""; 	local b=""; 	local step=""; 	local total=""; 	if [ -d "$g/rebase-merge" ]; then 		__git_eread "$g/rebase-merge/head-name" b; 		__git_eread "$g/rebase-merge/msgnum" step; 		__git_eread "$g/rebase-merge/end" total; 		if [ -f "$g/rebase-merge/interactive" ]; then 			r="|REBASE-i"; 		else 			r="|REBASE-m"; 		fi; 	else 		if [ -d "$g/rebase-apply" ]; then 			__git_eread "$g/rebase-apply/next" step; 			__git_eread "$g/rebase-apply/last" total; 			if [ -f "$g/rebase-apply/rebasing" ]; then 				__git_eread "$g/rebase-apply/head-name" b; 				r="|REBASE"; 			elif [ -f "$g/rebase-apply/applying" ]; then 				r="|AM"; 			else 				r="|AM/REBASE"; 			fi; 		elif [ -f "$g/MERGE_HEAD" ]; then 			r="|MERGING"; 		elif [ -f "$g/CHERRY_PICK_HEAD" ]; then 			r="|CHERRY-PICKING"; 		elif [ -f "$g/REVERT_HEAD" ]; then 			r="|REVERTING"; 		elif [ -f "$g/BISECT_LOG" ]; then 			r="|BISECTING"; 		fi;  		if [ -n "$b" ]; then 			:; 		elif [ -h "$g/HEAD" ]; then 			b="$(git symbolic-ref HEAD 2>/dev/null)"; 		else 			local head=""; 			if ! __git_eread "$g/HEAD" head; then 				return $exit; 			fi 			b="${head#ref: }"; 			if [ "$head" = "$b" ]; then 				detached=yes; 				b="$(
  206  				case "${GIT_PS1_DESCRIBE_STYLE-}" in
  207  				(contains)
  208  					git describe --contains HEAD ;;
  209  				(branch)
  210  					git describe --contains --all HEAD ;;
  211  				(describe)
  212  					git describe HEAD ;;
  213  				(* | default)
  214  					git describe --tags --exact-match HEAD ;;
  215  				esac 2>/dev/null)" || 				b="$short_sha..."; 				b="($b)"; 			fi; 		fi; 	fi;  	if [ -n "$step" ] && [ -n "$total" ]; then 		r="$r $step/$total"; 	fi;  	local w=""; 	local i=""; 	local s=""; 	local u=""; 	local c=""; 	local p="";  	if [ "true" = "$inside_gitdir" ]; then 		if [ "true" = "$bare_repo" ]; then 			c="BARE:"; 		else 			b="GIT_DIR!"; 		fi; 	elif [ "true" = "$inside_worktree" ]; then 		if [ -n "${GIT_PS1_SHOWDIRTYSTATE-}" ] && 		   [ "$(git config --bool bash.showDirtyState)" != "false" ]; 		then 			git diff --no-ext-diff --quiet || w="*"; 			git diff --no-ext-diff --cached --quiet || i="+"; 			if [ -z "$short_sha" ] && [ -z "$i" ]; then 				i="#"; 			fi; 		fi; 		if [ -n "${GIT_PS1_SHOWSTASHSTATE-}" ] && 		   git rev-parse --verify --quiet refs/stash >/dev/null; 		then 			s="$"; 		fi;  		if [ -n "${GIT_PS1_SHOWUNTRACKEDFILES-}" ] && 		   [ "$(git config --bool bash.showUntrackedFiles)" != "false" ] && 		   git ls-files --others --exclude-standard --directory --no-empty-directory --error-unmatch -- ':/*' >/dev/null 2>/dev/null; 		then 			u="%${ZSH_VERSION+%}"; 		fi;  		if [ -n "${GIT_PS1_SHOWUPSTREAM-}" ]; then 			__git_ps1_show_upstream; 		fi; 	fi;  	local z="${GIT_PS1_STATESEPARATOR-" "}";  	if [ $pcmode = yes ] && [ -n "${GIT_PS1_SHOWCOLORHINTS-}" ]; then 		__git_ps1_colorize_gitstring; 	fi;  	b=${b##refs/heads/}; 	if [ $pcmode = yes ] && [ $ps1_expanded = yes ]; then 		__git_ps1_branch_name=$b; 		b="\${__git_ps1_branch_name}"; 	fi;  	local f="$w$i$s$u"; 	local gitstring="$c$b${f:+$z$f}$r$p";  	if [ $pcmode = yes ]; then 		if [ "${__git_printf_supports_v-}" != yes ]; then 			gitstring=$(printf -- "$printf_format" "$gitstring"); 		else 			printf -v gitstring -- "$printf_format" "$gitstring"; 		fi; 		PS1="$ps1pc_start$gitstring$ps1pc_end"; 	else 		printf -- "$printf_format" "$gitstring"; 	fi;  	return $exit; }
  216  # bash/zsh git prompt support
  217  #
  218  # Copyright (C) 2006,2007 Shawn O. Pearce <spearce@spearce.org>
  219  # Distributed under the GNU General Public License, version 2.0.
  220  #
  221  # This script allows you to see repository status in your prompt.
  222  #
  223  # To enable:
  224  #
  225  #    1) Copy this file to somewhere (e.g. ~/.git-prompt.sh).
  226  #    2) Add the following line to your .bashrc/.zshrc:
  227  #        source ~/.git-prompt.sh
  228  #    3a) Change your PS1 to call __git_ps1 as
  229  #        command-substitution:
  230  #        Bash: PS1='[\u@\h \W$(__git_ps1 " (%s)")]\$ '
  231  #        ZSH:  setopt PROMPT_SUBST ; PS1='[%n@%m %c$(__git_ps1 " (%s)")]\$ '
  232  #        the optional argument will be used as format string.
  233  #    3b) Alternatively, for a slightly faster prompt, __git_ps1 can
  234  #        be used for PROMPT_COMMAND in Bash or for precmd() in Zsh
  235  #        with two parameters, <pre> and <post>, which are strings
  236  #        you would put in $PS1 before and after the status string
  237  #        generated by the git-prompt machinery.  e.g.
  238  #        Bash: PROMPT_COMMAND='__git_ps1 "\u@\h:\w" "\\\$ "'
  239  #          will show username, at-sign, host, colon, cwd, then
  240  #          various status string, followed by dollar and SP, as
  241  #          your prompt.
  242  #        ZSH:  precmd () { __git_ps1 "%n" ":%~$ " "|%s" }
  243  #          will show username, pipe, then various status string,
  244  #          followed by colon, cwd, dollar and SP, as your prompt.
  245  #        Optionally, you can supply a third argument with a printf
  246  #        format string to finetune the output of the branch status
  247  #
  248  # The repository status will be displayed only if you are currently in a
  249  # git repository. The %s token is the placeholder for the shown status.
  250  #
  251  # The prompt status always includes the current branch name.
  252  #
  253  # In addition, if you set GIT_PS1_SHOWDIRTYSTATE to a nonempty value,
  254  # unstaged (*) and staged (+) changes will be shown next to the branch
  255  # name.  You can configure this per-repository with the
  256  # bash.showDirtyState variable, which defaults to true once
  257  # GIT_PS1_SHOWDIRTYSTATE is enabled.
  258  #
  259  # You can also see if currently something is stashed, by setting
  260  # GIT_PS1_SHOWSTASHSTATE to a nonempty value. If something is stashed,
  261  # then a '$' will be shown next to the branch name.
  262  #
  263  # If you would like to see if there're untracked files, then you can set
  264  # GIT_PS1_SHOWUNTRACKEDFILES to a nonempty value. If there're untracked
  265  # files, then a '%' will be shown next to the branch name.  You can
  266  # configure this per-repository with the bash.showUntrackedFiles
  267  # variable, which defaults to true once GIT_PS1_SHOWUNTRACKEDFILES is
  268  # enabled.
  269  #
  270  # If you would like to see the difference between HEAD and its upstream,
  271  # set GIT_PS1_SHOWUPSTREAM="auto".  A "<" indicates you are behind, ">"
  272  # indicates you are ahead, "<>" indicates you have diverged and "="
  273  # indicates that there is no difference. You can further control
  274  # behaviour by setting GIT_PS1_SHOWUPSTREAM to a space-separated list
  275  # of values:
  276  #
  277  #     verbose       show number of commits ahead/behind (+/-) upstream
  278  #     name          if verbose, then also show the upstream abbrev name
  279  #     legacy        don't use the '--count' option available in recent
  280  #                   versions of git-rev-list
  281  #     git           always compare HEAD to @{upstream}
  282  #     svn           always compare HEAD to your SVN upstream
  283  #
  284  # You can change the separator between the branch name and the above
  285  # state symbols by setting GIT_PS1_STATESEPARATOR. The default separator
  286  # is SP.
  287  #
  288  # By default, __git_ps1 will compare HEAD to your SVN upstream if it can
  289  # find one, or @{upstream} otherwise.  Once you have set
  290  # GIT_PS1_SHOWUPSTREAM, you can override it on a per-repository basis by
  291  # setting the bash.showUpstream config variable.
  292  #
  293  # If you would like to see more information about the identity of
  294  # commits checked out as a detached HEAD, set GIT_PS1_DESCRIBE_STYLE
  295  # to one of these values:
  296  #
  297  #     contains      relative to newer annotated tag (v1.6.3.2~35)
  298  #     branch        relative to newer tag or branch (master~4)
  299  #     describe      relative to older annotated tag (v1.6.3.1-13-gdd42c2f)
  300  #     default       exactly matching tag
  301  #
  302  # If you would like a colored hint about the current dirty state, set
  303  # GIT_PS1_SHOWCOLORHINTS to a nonempty value. The colors are based on
  304  # the colored output of "git status -sb" and are available only when
  305  # using __git_ps1 for PROMPT_COMMAND or precmd.
  306  #
  307  # If you would like __git_ps1 to do nothing in the case when the current
  308  # directory is set up to be ignored by git, then set
  309  # GIT_PS1_HIDE_IF_PWD_IGNORED to a nonempty value. Override this on the
  310  # repository level by setting bash.hideIfPwdIgnored to "false".
  311  # check whether printf supports -v
  312  __git_printf_supports_v=
  313  printf -v __git_printf_supports_v -- '%s' yes >/dev/null 2>&1
  314  # stores the divergence from upstream in $p
  315  # used by GIT_PS1_SHOWUPSTREAM
  316  __git_ps1_show_upstream () { 	local key value; 	local svn_remote svn_url_pattern count n; 	local upstream=git legacy="" verbose="" name="";  	svn_remote=() 	local output="$(git config -z --get-regexp '^(svn-remote\..*\.url|bash\.showupstream)$' 2>/dev/null | tr '\0\n' '\n ')"; 	while read -r key value; do 		case "$key" in 		bash.showupstream) 			GIT_PS1_SHOWUPSTREAM="$value"; 			if [[ -z "${GIT_PS1_SHOWUPSTREAM}" ]]; then 				p=""; 				return; 			fi; 			;; 		svn-remote.*.url) 			svn_remote[$((${#svn_remote[@]} + 1))]="$value"; 			svn_url_pattern="$svn_url_pattern\\|$value"; 			upstream=svn+git # default upstream is SVN if available, else git; 			;; 		esac
  317  	done <<< "$output";  	for option in ${GIT_PS1_SHOWUPSTREAM}; do 		case "$option" in 		git|svn) upstream="$option" ;; 		verbose) verbose=1 ;; 		legacy)  legacy=1  ;; 		name)    name=1 ;; 		esac; 	done;  	case "$upstream" in 	git)    upstream="@{upstream}" ;; 	svn*) 		local -a svn_upstream; 		svn_upstream=($(git log --first-parent -1 \
  318  					--grep="^git-svn-id: \(${svn_url_pattern#??}\)" 2>/dev/null)); 		if [[ 0 -ne ${#svn_upstream[@]} ]]; then 			svn_upstream=${svn_upstream[${#svn_upstream[@]} - 2]}; 			svn_upstream=${svn_upstream%@*}; 			local n_stop="${#svn_remote[@]}"; 			for ((n=1; n <= n_stop; n++)); do 				svn_upstream=${svn_upstream#${svn_remote[$n]}}; 			done;  			if [[ -z "$svn_upstream" ]]; then 				upstream=${GIT_SVN_ID:-git-svn}; 			else 				upstream=${svn_upstream#/}; 			fi; 		elif [[ "svn+git" = "$upstream" ]]; then 			upstream="@{upstream}"; 		fi; 		;; 	esac;  	if [[ -z "$legacy" ]]; then 		count="$(git rev-list --count --left-right \
  319  				"$upstream"...HEAD 2>/dev/null)"; 	else 		local commits; 		if commits="$(git rev-list --left-right "$upstream"...HEAD 2>/dev/null)"; 		then 			local commit behind=0 ahead=0; 			for commit in $commits; 			do 				case "$commit" in 				"<"*) ((behind++)) ;; 				*)    ((ahead++))  ;; 				esac; 			done; 			count="$behind	$ahead"; 		else 			count=""; 		fi; 	fi;  	if [[ -z "$verbose" ]]; then 		case "$count" in 		"") # no upstream 			p="" ;; 		"0	0") # equal to upstream 			p="=" ;; 		"0	"*) # ahead of upstream 			p=">" ;; 		*"	0") # behind upstream 			p="<" ;; 		*)	    # diverged from upstream 			p="<>" ;; 		esac; 	else 		case "$count" in 		"") # no upstream 			p="" ;; 		"0	0") # equal to upstream 			p=" u=" ;; 		"0	"*) # ahead of upstream 			p=" u+${count#0	}" ;; 		*"	0") # behind upstream 			p=" u-${count%	0}" ;; 		*)	    # diverged from upstream 			p=" u+${count#*	}-${count%	*}" ;; 		esac; 		if [[ -n "$count" && -n "$name" ]]; then 			__git_ps1_upstream_name=$(git rev-parse \
  320  				--abbrev-ref "$upstream" 2>/dev/null); 			if [ $pcmode = yes ] && [ $ps1_expanded = yes ]; then 				p="$p \${__git_ps1_upstream_name}"; 			else 				p="$p ${__git_ps1_upstream_name}" 				unset __git_ps1_upstream_name; 			fi; 		fi; 	fi;  }
  321  # Helper function that is meant to be called from __git_ps1.  It
  322  # injects color codes into the appropriate gitstring variables used
  323  # to build a gitstring.
  324  __git_ps1_colorize_gitstring () { 	if [[ -n ${ZSH_VERSION-} ]]; then 		local c_red='%F{red}'; 		local c_green='%F{green}'; 		local c_lblue='%F{blue}'; 		local c_clear='%f'; 	else 		local c_red='\[\e[31m\]'; 		local c_green='\[\e[32m\]'; 		local c_lblue='\[\e[1;34m\]'; 		local c_clear='\[\e[0m\]'; 	fi; 	local bad_color=$c_red; 	local ok_color=$c_green; 	local flags_color="$c_lblue";  	local branch_color=""; 	if [ $detached = no ]; then 		branch_color="$ok_color"; 	else 		branch_color="$bad_color"; 	fi; 	c="$branch_color$c";  	z="$c_clear$z"; 	if [ "$w" = "*" ]; then 		w="$bad_color$w"; 	fi; 	if [ -n "$i" ]; then 		i="$ok_color$i"; 	fi; 	if [ -n "$s" ]; then 		s="$flags_color$s"; 	fi; 	if [ -n "$u" ]; then 		u="$bad_color$u"; 	fi; 	r="$c_clear$r"; }
  325  __git_eread () { 	local f="$1"; 	shift; 	test -r "$f" && read "$@" <"$f"; }
  326  # __git_ps1 accepts 0 or 1 arguments (i.e., format string)
  327  # when called from PS1 using command substitution
  328  # in this mode it prints text to add to bash PS1 prompt (includes branch name)
  329  #
  330  # __git_ps1 requires 2 or 3 arguments when called from PROMPT_COMMAND (pc)
  331  # in that case it _sets_ PS1. The arguments are parts of a PS1 string.
  332  # when two arguments are given, the first is prepended and the second appended
  333  # to the state string when assigned to PS1.
  334  # The optional third parameter will be used as printf format string to further
  335  # customize the output of the git-status string.
  336  # In this mode you can request colored hints using GIT_PS1_SHOWCOLORHINTS=true
  337  __git_ps1 () { 	local exit=$?; 	local pcmode=no; 	local detached=no; 	local ps1pc_start='\u@\h:\w '; 	local ps1pc_end='\$ '; 	local printf_format=' (%s)';  	case "$#" in 		2|3)	pcmode=yes; 			ps1pc_start="$1"; 			ps1pc_end="$2"; 			printf_format="${3:-$printf_format}" 			PS1="$ps1pc_start$ps1pc_end"; 		;; 		0|1)	printf_format="${1:-$printf_format}"; 		;; 		*)	return $exit; 		;; 	esac;  	local ps1_expanded=yes; 	[ -z "$ZSH_VERSION" ] || [[ -o PROMPT_SUBST ]] || ps1_expanded=no; 	[ -z "$BASH_VERSION" ] || shopt -q promptvars || ps1_expanded=no;  	local repo_info rev_parse_exit_code; 	repo_info="$(git rev-parse --git-dir --is-inside-git-dir \
  338  		--is-bare-repository --is-inside-work-tree \
  339  		--short HEAD 2>/dev/null)"; 	rev_parse_exit_code="$?";  	if [ -z "$repo_info" ]; then 		return $exit; 	fi;  	local short_sha; 	if [ "$rev_parse_exit_code" = "0" ]; then 		short_sha="${repo_info##*$'\n'}"; 		repo_info="${repo_info%$'\n'*}"; 	fi; 	local inside_worktree="${repo_info##*$'\n'}"; 	repo_info="${repo_info%$'\n'*}"; 	local bare_repo="${repo_info##*$'\n'}"; 	repo_info="${repo_info%$'\n'*}"; 	local inside_gitdir="${repo_info##*$'\n'}"; 	local g="${repo_info%$'\n'*}";  	if [ "true" = "$inside_worktree" ] && 	   [ -n "${GIT_PS1_HIDE_IF_PWD_IGNORED-}" ] && 	   [ "$(git config --bool bash.hideIfPwdIgnored)" != "false" ] && 	   git check-ignore -q .; 	then 		return $exit; 	fi;  	local r=""; 	local b=""; 	local step=""; 	local total=""; 	if [ -d "$g/rebase-merge" ]; then 		__git_eread "$g/rebase-merge/head-name" b; 		__git_eread "$g/rebase-merge/msgnum" step; 		__git_eread "$g/rebase-merge/end" total; 		if [ -f "$g/rebase-merge/interactive" ]; then 			r="|REBASE-i"; 		else 			r="|REBASE-m"; 		fi; 	else 		if [ -d "$g/rebase-apply" ]; then 			__git_eread "$g/rebase-apply/next" step; 			__git_eread "$g/rebase-apply/last" total; 			if [ -f "$g/rebase-apply/rebasing" ]; then 				__git_eread "$g/rebase-apply/head-name" b; 				r="|REBASE"; 			elif [ -f "$g/rebase-apply/applying" ]; then 				r="|AM"; 			else 				r="|AM/REBASE"; 			fi; 		elif [ -f "$g/MERGE_HEAD" ]; then 			r="|MERGING"; 		elif [ -f "$g/CHERRY_PICK_HEAD" ]; then 			r="|CHERRY-PICKING"; 		elif [ -f "$g/REVERT_HEAD" ]; then 			r="|REVERTING"; 		elif [ -f "$g/BISECT_LOG" ]; then 			r="|BISECTING"; 		fi;  		if [ -n "$b" ]; then 			:; 		elif [ -h "$g/HEAD" ]; then 			b="$(git symbolic-ref HEAD 2>/dev/null)"; 		else 			local head=""; 			if ! __git_eread "$g/HEAD" head; then 				return $exit; 			fi 			b="${head#ref: }"; 			if [ "$head" = "$b" ]; then 				detached=yes; 				b="$(
  340  				case "${GIT_PS1_DESCRIBE_STYLE-}" in
  341  				(contains)
  342  					git describe --contains HEAD ;;
  343  				(branch)
  344  					git describe --contains --all HEAD ;;
  345  				(describe)
  346  					git describe HEAD ;;
  347  				(* | default)
  348  					git describe --tags --exact-match HEAD ;;
  349  				esac 2>/dev/null)" || 				b="$short_sha..."; 				b="($b)"; 			fi; 		fi; 	fi;  	if [ -n "$step" ] && [ -n "$total" ]; then 		r="$r $step/$total"; 	fi;  	local w=""; 	local i=""; 	local s=""; 	local u=""; 	local c=""; 	local p="";  	if [ "true" = "$inside_gitdir" ]; then 		if [ "true" = "$bare_repo" ]; then 			c="BARE:"; 		else 			b="GIT_DIR!"; 		fi; 	elif [ "true" = "$inside_worktree" ]; then 		if [ -n "${GIT_PS1_SHOWDIRTYSTATE-}" ] && 		   [ "$(git config --bool bash.showDirtyState)" != "false" ]; 		then 			git diff --no-ext-diff --quiet || w="*"; 			git diff --no-ext-diff --cached --quiet || i="+"; 			if [ -z "$short_sha" ] && [ -z "$i" ]; then 				i="#"; 			fi; 		fi; 		if [ -n "${GIT_PS1_SHOWSTASHSTATE-}" ] && 		   git rev-parse --verify --quiet refs/stash >/dev/null; 		then 			s="$"; 		fi;  		if [ -n "${GIT_PS1_SHOWUNTRACKEDFILES-}" ] && 		   [ "$(git config --bool bash.showUntrackedFiles)" != "false" ] && 		   git ls-files --others --exclude-standard --directory --no-empty-directory --error-unmatch -- ':/*' >/dev/null 2>/dev/null; 		then 			u="%${ZSH_VERSION+%}"; 		fi;  		if [ -n "${GIT_PS1_SHOWUPSTREAM-}" ]; then 			__git_ps1_show_upstream; 		fi; 	fi;  	local z="${GIT_PS1_STATESEPARATOR-" "}";  	if [ $pcmode = yes ] && [ -n "${GIT_PS1_SHOWCOLORHINTS-}" ]; then 		__git_ps1_colorize_gitstring; 	fi;  	b=${b##refs/heads/}; 	if [ $pcmode = yes ] && [ $ps1_expanded = yes ]; then 		__git_ps1_branch_name=$b; 		b="\${__git_ps1_branch_name}"; 	fi;  	local f="$w$i$s$u"; 	local gitstring="$c$b${f:+$z$f}$r$p";  	if [ $pcmode = yes ]; then 		if [ "${__git_printf_supports_v-}" != yes ]; then 			gitstring=$(printf -- "$printf_format" "$gitstring"); 		else 			printf -v gitstring -- "$printf_format" "$gitstring"; 		fi; 		PS1="$ps1pc_start$gitstring$ps1pc_end"; 	else 		printf -- "$printf_format" "$gitstring"; 	fi;  	return $exit; }
  350  ls
  351  git git remote add origin https://github.com/nilakshgupta/test_dvc.git
  352  git remote add origin https://github.com/nilakshgupta/test_dvc.git
  353  git init
  354  git remote add origin https://github.com/nilakshgupta/test_dvc.git
  355  conda create -dvc-ml python = 3.7 -y
  356  conda create - dvc-ml python = 3.7 -y
  357  conda create - dvc-ml python=3.7 -y
  358  onda create -n dvc-ml python=3.7 -y
  359  conda create -n dvc-ml python=3.7 -y
  360  conda activate dvc-ml
  361  git branch -M main
  362  touch .gitignore
  363  touch READ.md
  364  clear
  365  git status
  366  git add .
  367  git commit -m"first commit"
  368  git push origin main
  369  clear
  370  git status
  371  git add .gitignore
  372  git commit -m"updated .gitignore"
  373  git push origin main
  374  clearf
  375  clear
  376  history >log.txt
